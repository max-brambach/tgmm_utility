import numpy as np
import pandas as pd
import xml.etree.ElementTree as ET
import tqdm
import glob
import os
import random

def read_tgmm(xml_path):
    """
    Read single cell segmentation results from TGMM (McDole et al., Cell, 2018) and return as pandas DataFrame.
    Input is a folder containing the .xml files generated by TGMM. Those have the default name
    'GMEMfinalResult_frame????.xml' (???? = frame number, e.g. 0001).
    The returned DataFrame contains single cells as rows and their specifics as columns. The latter are:
    * index: running index generated by the DataFrame
    * cell id: unique id of a cell in a given frame
    * parent id: cell id of parent cell in previous frame. -1 indicates the beginning of a track.
    * split score: confidence level for the correct tracking of this particular object. A value of 0 indicates very low
        confidence and a value of 5 indicates very high confidence. Sorting elements by confidence level can guide the
        user in the data curation process and facilitate more effective editing of the TGMM results.
    * nu: cell shape prior
    * beta: cell position prior
    * alpha: track consistency prior
    * x, y, z: cartesian coordinates of the nucleus.
    * precision matrix: np.array, inverse of the covariance matrix of the multivariate Gaussian distribution used for
        fitting the nucleus. Encodes nuclear shape (eigenvectors = main axes, 1/eigenvalues ~ length of main axes).
    * frame: number of the time frame
    :param xml_path: str, path to a TGMM generated .xml file
    :param labels: dict, key=column name, val=value of the column (can be single or list)
    :return: pd.DataFrame, containing individual cells per row and corresponding information as mentioned above.
    """
    names = ['cell id TGMM', 'parent id TGMM', 'split score', 'nu', 'beta', 'alpha', 'x', 'y', 'z',
             'precision matrix']
    tree = ET.parse(xml_path)
    root = tree.getroot()
    l = []
    for cell in root.iter('GaussianMixtureModel'):
        try:
            id = int(cell.attrib['id'])
            parent_id = int(cell.attrib['parent'])
            split_score = float(cell.attrib['splitScore'])
            nu = float(cell.attrib['nu'])
            beta = float(cell.attrib['beta'])
            alpha = float(cell.attrib['alpha'])
            xyz = np.array(cell.attrib['m'].split(' ')[0:3], dtype=np.float)
            x, y, z = tuple(xyz)
            p_mtrx = np.array(cell.attrib['W'].split(' ')[0:-1], dtype=np.float).reshape((3, 3))
            if np.any(p_mtrx == np.inf):
                continue
        except ValueError:
            continue
        l.append([id, parent_id, split_score, nu, beta, alpha, x, y, z, p_mtrx])
    out = pd.DataFrame(l, columns=names)
    out['cell id'] = out['cell id TGMM'] + 1
    return out